#include "glad/glad.h"
#include "GLFW/glfw3.h"
#include "stb_image.h"

#include "stdio.h"
#include "stdbool.h"
#include "string.h"

#include "engine_core/hash_table.h"
#include "texture.h"


static HashTable* TextureTable;

bool FindTexture(const char* alias, Texture** outValue) {
    return HashTable_find(TextureTable, alias, outValue);
}

void InitTextures() {
    TextureTable = HashTable_create(Texture, 512);
}

void InternalUploadTexture(Texture* texture, uint8_t* data, GLenum internalFormat, GLenum format, GLenum uploadType) {
    
    if (texture->ID == GL_NONE) {
        glGenTextures(1, &(texture->ID));
    }

    glBindTexture(texture->type, texture->ID);
    glTextureParameteri(texture->ID, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTextureParameteri(texture->ID, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTextureParameteri(texture->ID, GL_TEXTURE_MIN_FILTER, texture->filterType);
    glTextureParameteri(texture->ID, GL_TEXTURE_MAG_FILTER, texture->filterType);
    glTexImage2D(uploadType, 0, internalFormat, texture->width, texture->height, 0, format, GL_UNSIGNED_BYTE, data);
}

void InternalUploadTextureMimmap(Texture* texture, uint8_t* data, GLenum internalFormat, GLenum format, GLenum uploadType) {
    
    if (texture->ID == GL_NONE) {
        glGenTextures(1, &texture->ID);
    }

    glBindTexture(texture->type, texture->ID);
    glTextureParameteri(texture->ID, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTextureParameteri(texture->ID, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTextureParameteri(texture->ID, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTextureParameteri(texture->ID, GL_TEXTURE_MAG_FILTER, texture->filterType);
    glTexImage2D(uploadType, 0, internalFormat, texture->width, texture->height, 0, format, GL_UNSIGNED_BYTE, data);
    glGenerateMipmap(texture->type);
}

void InternalDeleteTexture(Texture* texture) {
    if (--texture->references != 0) return;

    if (texture->ID != GL_NONE) {
        glDeleteTextures(1, &(texture->ID));
    }
    texture->ID = GL_NONE;
    HashTable_remove(TextureTable, texture->alias);

}


void InternalCreateTexture(Texture* texture, const bool isManaged, const char* alias, const GLenum internalFormat, const GLenum format, uint8_t* data, bool useMipmap) {
    /* Internal function for creating managed textures. */

    if (useMipmap) {
        InternalUploadTextureMimmap(texture, data, internalFormat, format, GL_TEXTURE_2D);
    }
    else {
        InternalUploadTexture(texture, data, internalFormat, format, GL_TEXTURE_2D);
    }

    texture->alias = HashTable_insert(TextureTable, alias, texture);
    
    texture->references++;

}


void CreateRawTexture(const char* path, Texture* texture, GLenum internalFormat, GLenum format, bool flipVertical, bool flipHorizontal, bool useMipmaps, int filterType) {
    /* This function creates a new, unmanaged texture from the file path and the alias. if the texture already exists in memory, the returned value will be that one. */

    texture->filterType = filterType;

    stbi_set_flip_vertically_on_load(true);
    uint8_t* data = stbi_load(path, &texture->width, &texture->height, &texture->channels, 0);

    if (!data) {
        printf("Error creating raw Texture from: \" %s \". The texture will be discarded.", path);
        return;
    }

    // Create the managed texture and upload the texture to the GPU.
    InternalCreateTexture(texture, true, path, internalFormat, format, data, useMipmaps);

    // Free the data generated by stb_image.
    stbi_image_free(data);

}

Texture* CreateTexture(const char* path, const char* alias, GLenum internalFormat, bool flipVertical, bool flipHorizontal, bool useMipmaps, int filterType) {
    /* This function creates a new texture from the file path and the alias. if the texture already exists in memory, the returned value will be that one.
    This will hopefully save delectably scrumptious graphics memory mmmhh. If an alias is not provided, the texture will use it's path as an alias. */

    char* aliasUsed;
    Texture* texture = NULL;

    // If the alias is empty, use the path instead.
    if (!strcmp(alias, "")) { aliasUsed = (char*)path; }
    else { aliasUsed = (char*)alias; }

    // try to find the texture in the table.
    HashTable_find(TextureTable, aliasUsed, &texture);

    // if it is found in the table, return it instead of making a new one.
    if (texture) {
        return texture;
    }

    internal_Texture_create(texture, GL_TEXTURE_2D, filterType);

    stbi_set_flip_vertically_on_load(true);
    uint8_t* data = stbi_load(path, &texture->width, &texture->height, &texture->channels, 0);

    if (!data) {
        printf("Error creating Texture: \"%s\" From: \"%s\". The Texture will be discarded.", aliasUsed, path);
        return NULL;
    }

    GLenum format = GL_NONE;

    switch (texture->channels) {
        case 1: format = GL_RED; break;
        case 2: format = GL_RG; break;
        case 3: format = GL_RGB; break;
        case 4: format = GL_RGBA; break;
    }

    // Create the managed texture and upload the texture to the GPU.
    InternalCreateTexture(texture, false, aliasUsed, internalFormat, format, data, useMipmaps);

    // Free the data generated by stb_image.
    stbi_image_free(data);

    return texture;
}


Texture* CreateCubemapTexture(const char* texturePaths[6], const char* alias, GLenum internalFormat, bool flipVertical, bool flipHorizontal, bool useMipmaps, int filterType) {

    Texture* texture = NULL;
    HashTable_find(TextureTable, alias, &texture);

    // if the texture doesn't already exist, make a new one, and return that instead.
    if (texture) {
        return texture;
    }
    
    internal_Texture_create(texture, GL_TEXTURE_CUBE_MAP, filterType);

    for (uint16_t i = 0; i < 6; i++) {

        stbi_set_flip_vertically_on_load(true);
        uint8_t* data = stbi_load(texturePaths[i], &texture->width, &texture->height, &texture->channels, 0);
        
        if (!data) {
            printf("Error creating Cube Map Texture: \"%s\" At index, %d, From: \"%s\". The texture will be discarded.", alias, i, texturePaths[i]);
            return NULL;
        }

        GLenum format = GL_NONE;

        switch (texture->channels) {
            case 1: format = GL_RED; break;
            case 2: format = GL_RG; break;
            case 3: format = GL_RGB; break;
            case 4: format = GL_RGBA; break;
        }

        InternalUploadTexture(texture, data, internalFormat, format, GL_TEXTURE_CUBE_MAP_POSITIVE_X + i);
        stbi_image_free(data);
    }

    return texture;
}


void DeleteTexture(const char* alias) {
    /* This function manages deleting textures from the table. The texture will be deleted from graphics memory if it isn't referenced anywhere. */

    if (!alias) return;

    Texture* texture = NULL;

    HashTable_find(TextureTable, alias, &texture);

    if (!texture) {
        printf("Error deleting Texture: \"%s\". No Texture with that name found.", alias);
        return;
    }

    InternalDeleteTexture(texture);
}


void DereferenceTextures() {
    /* Call this function at the end of your program to ensure all tracked textures are properly cleaned up. */

    // Iterate through all the positions in the hash table.
    for (HashTable_array_iterator(TextureTable)) {
        Texture* texture = HashTable_array_at(Texture, TextureTable, i);
        texture->references = 1;
        InternalDeleteTexture(texture);
    }
    HashTable_destroy(&TextureTable);
}
